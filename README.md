# Кривошеев Максим УИБО-14-24
# Алгоритмы сортировки и поиска
## 1.Сортировка выбором.
Сортировка выбором (Selection Sort) — это простой алгоритм сортировки, который последовательно находит минимальный элемент в несортированной части массива и перемещает его в начало отсортированной части. Этот процесс повторяется до тех пор, пока весь массив не станет отсортированным.
#### Объяснение работы алгоритма:
1) Разделяем массив на отсортированную и несортированную части.
2) Находим минимальный элемент в несортированной части.
3) Меняем его местами с первым элементом несортированной части.
4) Повторяем шаги 2 и 3, пока весь массив не будет отсортирован.
##### Временная сложность: 
O(n^2). Это связано с двумя вложенными циклами: внешний цикл проходит по всем элементам, внутренний ищет минимальный элемент в оставшейся части массива.
## 2.Сортировка обменом.
Сортировка обменом (Bubble Sort) — это простой алгоритм сортировки, который многократно проходит по списку, сравнивая смежные элементы и меняя их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока весь список не будет отсортирован.
#### Объяснение работы алгоритма:
1) Инициализация:
n = len(arr) — получаем длину массива.
Внешний цикл for i in range(n - 1) выполняется n-1 раз (достаточно для сортировки, так как последний элемент автоматически займет свое место).
2) Внутренний цикл и проверка:
swapped = False — флаг, который отслеживает, были ли обмены во внутреннем цикле.
Внутренний цикл for j in range(n - i - 1) проходит по неотсортированной части массива (после каждого прохода самый большой элемент "всплывает" в конец).
Сравниваются соседние элементы arr[j] и arr[j + 1]. Если arr[j] > arr[j + 1], они меняются местами, и swapped устанавливается в True.
3) Оптимизация:
Если во внутреннем цикле не было ни одного обмена (swapped остался False), массив уже отсортирован, и алгоритм досрочно завершает работу (break).
#### Временная сложность: 
**Худший случай:** O(n^2), где n — количество элементов массива. Это происходит тогда, когда массив отсортирован в обратном порядке, и каждый элемент приходится сравнивать и перемещать почти со всеми остальными элементами.

**Средний случай:** также O(n^2). Поскольку алгоритм требует сравнения каждого элемента практически со всеми последующими элементами, среднее число сравнений примерно равно квадрату размера массива.

**Лучший случай:** O(n) (линейная сложность). Такой случай возникает, если массив изначально отсортирован. Тогда первый проход завершится без обменов, и алгоритм остановится досрочно благодаря флагу swapped.
## 3.Сортировка вставками.
Сортировка вставками (Insertion Sort) — это простой алгоритм сортировки, который работает путем постепенного построения отсортированной части массива. На каждом шаге новый элемент вставляется в уже отсортированную часть массива на своё правильное место.
#### Объяснение работы алгоритма:
1) Предположение: Начнём с того, что первый элемент массива уже отсортирован.
2) Выбор элемента: Берём следующий элемент массива и сравниваем его с элементами в уже отсортированной части.
3) Вставка: Если текущий элемент меньше какого-либо элемента в отсортированной части, сдвигаем большие элементы вправо, создавая свободное место для вставки текущего элемента.
4) Повторение: Повторяем этот процесс для каждого последующего элемента, пока весь массив не будет отсортирован.
##### Временная сложность:
O(n^2), так как в большинстве случаев требуется сравнение и перемещение элементов.
## 4.Сортировка слиянием.
Сортировка слиянием (Merge Sort) — это эффективный алгоритм сортировки, который использует принцип "разделяй и властвуй". Он работает путём разделения массива на две половины, сортировки каждой половины рекурсивно и последующего объединения двух отсортированных половин в один отсортированный массив.
#### Объяснение работы алгоритма:
1)Разбиение массива: Массив делится на две примерно равные части.
2)Рекурсия: Каждая половина снова делится на две части, и этот процесс продолжается до тех пор, пока каждая часть не станет содержать один элемент (один элемент автоматически считается отсортированным).
3)Объединение: Две отсортированные части объединяются в один отсортированный массив. Это объединение происходит путём сравнения элементов из обеих частей и выбора меньшего из них для добавления в результирующий массив.
##### Временная сложность:
O(nlogn), где n — количество элементов в массиве.
## 5.Сортировка Шелла.
Сортировка Шелла — это алгоритм сортировки, который является обобщением сортировки вставками. Он сортирует элементы, сравнивая и перемещая элементы, находящиеся на определенном расстоянии друг от друга (шаг), постепенно уменьшая этот шаг до единицы. Это позволяет сначала устранить массовые нарушения порядка, что повышает эффективность финальной сортировки вставками.
#### Объяснение работы алгоритма:
1)Выбор шага: начальный шаг вычисляется как n/2, где n — размер массива. На каждой итерации шаг уменьшается вдвое, пока не станет равным 1.
2)Сортировка вставками с шагом: для каждого шага алгоритм выполняет сортировку вставками, но сравнивает и перемещает элементы, находящиеся на расстоянии step, а не соседние. Это позволяет элементам быстрее занимать правильные позиции.
3)Уменьшение шага: процесс повторяется с уменьшением шага, пока step не станет равным 1. На этом этапе массив почти отсортирован, и финальный проход с шагом 1 завершает сортировку.
##### Временная сложность:
варьируется от O(n log²n) до O(n²) в зависимости от выбора шагов.
## 6.Быстрая сортировка.
Быстрая сортировка — это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй". Алгоритм выбирает опорный элемент (pivot), разделяет массив на две части: элементы меньше опорного и элементы больше опорного, затем рекурсивно сортирует обе части.
#### Объяснение работы алгоритма:
1)Выбор опорного элемента (pivot): в данном коде выбирается последний элемент массива, но можно выбирать первый, средний или случайный элемент.
2)Разделение (partition): переставляем элементы так, чтобы все элементы меньше опорного оказались слева, а больше — справа. Используется два указателя: i (индекс последнего элемента в "меньшей" части) и j (текущий элемент). В конце цикла опорный элемент помещается на правильную позицию.
3)Рекурсия: рекурсивно применяем быструю сортировку к левой части (элементы < pivot). Рекурсивно применяем к правой части (элементы > pivot).
##### Временная сложность:
в среднем O(n log n).
## 7.Пирамидальная сортировка.
Пирамидальная сортировка — это алгоритм сортировки, основанный на структуре данных "двоичная куча". Алгоритм состоит из двух этапов: построение пирамиды (кучи) из исходного массива и последовательное извлечение максимальных элементов с перестройкой кучи.
#### Объяснение работы алгоритма:
Построение кучи (heapify):
1) Преобразуем массив в максимальную кучу, где каждый родительский узел больше своих дочерних.
2) Начинаем с последнего нелистового узла (индекс n/2 - 1) и движемся к корню.
Сортировка:
1) Максимальный элемент находится в корне (индекс 0).
2) Меняем корневой элемент с последним элементом массива.
3) Уменьшаем размер кучи на 1 и перестраиваем кучу для корня.
4) Повторяем процесс, пока в куче не останется один элемент.
##### Временная сложность:
Создание начальной кучи: O(N)

Извлечение каждого элемента и восстановление кучи: каждая операция heapify занимает O(logN), а таких операций N штук, следовательно общая сложность: O(N⋅logN)

Это значит, что независимо от порядка элементов в начальном массиве, сортировка будет выполняться за O(NlogN) операций, что лучше, чем у многих простых методов сортировки вроде пузырьковой или вставок. Однако, Heap Sort уступает другим методам типа быстрой сортировки (Quick Sort) в плане скорости на практике из-за большего количества необходимых обменов памяти.
## 8.Последовательный поиск.
Последовательный поиск — это простейший алгоритм поиска элемента в массиве или списке, при котором каждый элемент последовательно проверяется на соответствие искомому значению, начиная с начала структуры данных.
#### Объяснение работы алгоритма:
1)Начало: алгоритм начинает с первого элемента массива (индекс 0).
Сравнение: сравнивает текущий элемент с искомым значением.
2)Результат: если элементы совпадают - возвращает индекс текущего элемента.
3)Продолжение: если не совпадают - переходит к следующему элементу.
4)Завершение: процесс повторяется до тех пор, пока: Не будет найден искомый элемент или не будет достигнут конец массива (в этом случае возвращается -1).
##### Временная сложность:
O(1) для итеративной версии, O(n) для рекурсивной.
## 9.Бинарный поиск.
Бинарный поиск — это эффективный алгоритм поиска элемента в отсортированном массиве путём последовательного деления массива пополам и выбора нужной половины, пока элемент не найден либо область поиска не станет пустой.
#### Объяснение работы алгоритма:
Алгоритм бинарного поиска состоит из следующих шагов:
Инициализация: Определяются границы области поиска (left и right), соответствующие началу и концу массива соответственно.
Средняя точка: Вычисляется средняя позиция массива (mid = left + (right-left)/2) и проверяется значение элемента на этой позиции.
Проверка условия: Если искомый элемент равен значению среднего элемента, значит, поиск завершён успешно.
1) Если искомое число меньше значения в средней точке, тогда рекурсивно повторяем процесс для левой части массива (right = mid — 1).
2) Если искомое число больше значения в средней точке, тогда аналогично рассматриваем правую половину массива (left = mid + 1).
Итерация продолжается, пока граница слева не превышает границу справа. Если нужный элемент не обнаружен после завершения итераций, возвращаем индикатор неудачи (например, индекс -1).
##### Временная сложность:
O(logN), где N — количество элементов в массиве. Это связано с тем, что на каждой итерации размер области поиска уменьшается вдвое.
## 10.Интерполирующий поиск.
Интерполирующий поиск — это улучшенный вариант классического бинарного поиска, предназначенный для равномерных распределённых данных. Этот алгоритм пытается предсказать местоположение искомого элемента внутри отсортированного массива, используя формулу интерполяции, основанную на относительном положении текущего ключа относительно первых и последних элементов массива.
#### Объяснение работы алгоритма:
1)Выбор начальной позиции: используя формулу интерполяции, выбираем позицию, близкую к ожидаемой позиции искомого элемента.
2)Проверка выбранного элемента: если выбранный элемент равен искомому, поиск успешен. Если искомый элемент больше, обновляем нижнюю границу (low) и продолжаем поиск дальше. Если искомый элемент меньше, обновляем верхнюю границу (high) и сужаем область поиска.
3)Повторение цикла: процесс повторяется, пока диапазон поиска не сузится до пустоты (когда нижняя граница превысила верхнюю).
##### Временная сложность:
O(loglogN), когда данные равномерно распределены.
##### Средняя сложность:
Приблизительно такая же, как у бинарного поиска, O(logN)O(logN), однако часто быстрее на практике, поскольку выбирает лучшую стартовую позицию.
## 11.Фибоначчи поиск.
Фибоначчи-поиск — это разновидность двоичного поиска, использующая последовательность чисел Фибоначчи для эффективного нахождения заданного элемента в отсортированном массиве. Основное отличие от стандартного бинарного поиска заключается в том, что вместо простого деления массива пополам, Фибоначчи-поиск делит массив на части, размеры которых соответствуют двум соседним числам Фибоначчи.
#### Объяснение работы алгоритма:
Проверяется условие на значение параметра n:
1) Если n≤0n≤0, возвращается пустой список.
2) Если n=1n=1, возвращается список [0], содержащий одно число.
3) Если n=2n=2, возвращается список [0,1], содержащий два числа.

Для n>2n>2 создаётся начальная последовательность [0,1]. Затем циклом выполняется последовательное вычисление последующих членов ряда, начиная с третьего (i=2)(i=2).

Внутри цикла на каждой итерации новое число добавляется в конец списка путём суммирования двух последних элементов последовательности.
##### Временная сложность:
Для анализа временной сложности рассмотрим основные операции:
Количество операций внутри основного цикла зависит от значения n.
1) Каждый новый элемент рассчитывается за константное время путем простой арифметической операции (сложение).
2) Добавление нового элемента в конец списка также занимает константное время (операция append() в Python работает за O(1)).

Следовательно, общее количество шагов (итераций цикла) прямо пропорционально значению n. Таким образом, временная сложность алгоритма линейна и равна O(n).
